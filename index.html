<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Servidor do Caos ‚Äî Tecnomagia Qu√¢ntica</title>
  <link rel="stylesheet" href="assets/css/style.css" />
  <link rel="stylesheet" href="assets/css/animations.css" />
  <link rel="icon" href="assets/images/merkaba-icon.png" type="image/png">
  <style>
    :root {
      --neon-cyan: #0ff;
      --neon-magenta: #f0f;
      --neon-yellow: #ff0;
      --dark-bg: #000;
      --panel-bg: rgba(0, 20, 30, 0.7);
    }
    
    body {
      background: var(--dark-bg) url('assets/images/stars-bg.jpg') no-repeat center;
      background-size: cover;
      color: var(--neon-cyan);
      font-family: 'DejaVu Sans', monospace;
      overflow-x: hidden;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .ritual-panel {
      border: 1px solid var(--neon-cyan);
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
      padding: 2rem;
      margin: 2rem auto;
      max-width: 900px;
      text-align: center;
      backdrop-filter: blur(10px);
      background: var(--panel-bg);
      position: relative;
      z-index: 10;
      border-radius: 8px;
      animation: border-pulse 3s infinite alternate;
    }
    
    @keyframes border-pulse {
      from { box-shadow: 0 0 20px rgba(0, 255, 255, 0.4); }
      to { box-shadow: 0 0 40px rgba(0, 255, 255, 0.8), 0 0 60px rgba(0, 255, 255, 0.6); }
    }
    
    .glow { 
      text-shadow: 0 0 15px var(--neon-cyan);
      animation: text-glow 2s infinite alternate;
    }
    
    @keyframes text-glow {
      from { text-shadow: 0 0 5px var(--neon-cyan); }
      to { text-shadow: 0 0 15px var(--neon-cyan), 0 0 20px var(--neon-cyan); }
    }
    
    .pulse::after {
      content: '';
      position: absolute;
      top: -5px; 
      left: -5px; 
      right: -5px; 
      bottom: -5px;
      border: 1px solid var(--neon-cyan);
      border-radius: 10px;
      animation: pulse 2s infinite;
      pointer-events: none;
    }
    
    input, button {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border-radius: 5px;
      background: rgba(0, 30, 40, 0.8);
      border: 1px solid var(--neon-cyan);
      color: var(--neon-cyan);
      font-family: inherit;
    }
    
    input::placeholder {
      color: rgba(0, 255, 255, 0.6);
    }
    
    button {
      background: transparent;
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
      padding: 12px 30px;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s;
      margin: 1rem;
      font-weight: bold;
      position: relative;
      overflow: hidden;
    }
    
    button:hover {
      box-shadow: 0 0 30px var(--neon-cyan);
      transform: scale(1.05);
    }
    
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.4), transparent);
      transition: 0.5s;
    }
    
    button:hover::before {
      left: 100%;
    }
    
    .quantum-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin: 1rem auto;
      width: 150px;
    }
    
    .qubit {
      height: 30px;
      background: #444;
      border-radius: 5px;
      transition: all 0.3s;
    }
    
    .qubit.active {
      background: var(--neon-yellow);
      box-shadow: 0 0 15px var(--neon-yellow);
    }
    
    .status {
      margin-top: 2rem;
      color: var(--neon-cyan);
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .footer-link {
      color: var(--neon-cyan);
      text-decoration: none;
      font-size: 0.8rem;
      margin-top: 2rem;
      display: inline-block;
      padding: 8px 16px;
      border: 1px solid var(--neon-cyan);
      border-radius: 4px;
      transition: all 0.3s;
    }
    
    .footer-link:hover {
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 10px var(--neon-cyan);
    }
    
    #manifestation-display {
      height: 150px; 
      margin: 1rem auto; 
      border: 1px dashed var(--neon-cyan); 
      background: rgba(0, 0, 0, 0.7); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      color: var(--neon-cyan); 
      font-size: 0.9rem;
      border-radius: 5px;
      padding: 10px;
    }
    
    .config-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--panel-bg);
      border: 1px solid var(--neon-cyan);
      padding: 10px;
      border-radius: 5px;
      font-size: 0.8rem;
    }
    
    .config-toggle {
      cursor: pointer;
      color: var(--neon-cyan);
      text-decoration: underline;
    }
    
    #github-token-form {
      display: none;
      margin-top: 10px;
    }
    
    .next-cycle {
      margin-top: 15px;
      font-size: 0.9rem;
      color: var(--neon-yellow);
    }
  </style>
</head>
<body>

  <div class="ritual-panel">
    <h1>üåå SERVIDOR DO CAOS üåå</h1>
    <p class="glow">"Voc√™ n√£o est√° pedindo. Voc√™ est√° reescrevendo a realidade."</p>

    <form id="manifestForm">
      <input type="text" id="intent" placeholder="O que voc√™ deseja manifestar? (Ex: Sou pr√≥spero, saud√°vel e livre)" required>
      <input type="text" id="name" placeholder="Seu nome completo" required>
      <input type="text" id="birthDate" placeholder="Data de nascimento (DD/MM/AAAA)" required>
      <input type="file" id="testimonyPhoto" accept="image/*">
      <label for="testimonyPhoto">Foto sua (opcional)</label>
      <input type="file" id="radionicGraphic" accept="image/*">
      <label for="radionicGraphic">Gr√°fico radi√¥nico (opcional)</label>
      <button type="submit">‚ú® ENVIAR PEDIDO QU√ÇNTICO ‚ú®</button>
    </form>

    <div id="status"></div>
    <div id="manifestation-display">
      Aguardando seu pedido...
    </div>

    <div class="quantum-grid">
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
      <div class="qubit"></div>
    </div>

    <div class="next-cycle" id="next-cycle">Pr√≥ximo ciclo astrol√≥gico: calculando...</div>

    <div style="margin-top: 2rem;">
      <a href="realizacoes.html" class="footer-link">‚ñ∂Ô∏è VER O QUE J√Å SE REALIZOU</a>
    </div>
  </div>

  <div class="config-panel">
    <div class="config-toggle" onclick="toggleConfig()">‚öôÔ∏è Configura√ß√µes</div>
    <form id="github-token-form">
      <input type="password" id="github-token-input" placeholder="Token GitHub (ghp_)">
      <button type="button" onclick="saveToken()">Salvar</button>
    </form>
  </div>

  <!-- Scripts -->
  <script src="assets/js/crypto-js.min.js"></script>
  <script src="assets/js/noisejs.js"></script>
  <script src="assets/js/dsp.min.js"></script>
  <script src="assets/js/wavelet.js"></script>
  <script src="assets/js/qrcode.min.js"></script>
  <script>
    // Vari√°veis globais
    const HORARIOS_ASTROLOGICOS = [
      { h: 4, m: 30 }, { h: 7, m: 30 }, { h: 12, m: 0 },
      { h: 15, m: 30 }, { h: 19, m: 30 }, { h: 22, m: 0 }
    ];
    
    let GITHUB_TOKEN = localStorage.getItem('github_token') || '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';
    const OWNER = 'Est_Ela';
    const REPO = 'tecnomagia-servidor-do-caos';
    
    // Fun√ß√µes de configura√ß√£o
    function toggleConfig() {
      const form = document.getElementById('github-token-form');
      form.style.display = form.style.display === 'none' ? 'block' : 'none';
    }
    
    function saveToken() {
      const tokenInput = document.getElementById('github-token-input');
      GITHUB_TOKEN = tokenInput.value;
      localStorage.setItem('github_token', GITHUB_TOKEN);
      alert('Token salvo! O sistema est√° pronto para operar.');
      toggleConfig();
    }
    
    // Fun√ß√µes auxiliares da GitHub API
    async function fetchJson(url) {
      const res = await fetch(url, { headers: { Authorization: `token ${GITHUB_TOKEN}` } });
      if (!res.ok) throw new Error(`GitHub API error: ${res.status}`);
      return await res.json();
    }
    
    async function uploadFileToRepo(filename, blob) {
      const encodedContent = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(btoa(reader.result));
        reader.onerror = reject;
        reader.readAsBinaryString(blob);
      });

      const path = `manifestacoes/${filename}`;

      const checkRes = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`, {
        headers: { Authorization: `token ${GITHUB_TOKEN}` }
      });

      let sha = '';
      if (checkRes.ok) {
        const data = await checkRes.json();
        sha = data.sha;
      }

      const response = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`, {
        method: 'PUT',
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: `Manifesta√ß√£o ativada: ${filename}`,
          content: encodedContent,
          sha: sha
        })
      });

      if (!response.ok) throw new Error(`Falha ao subir ${filename}: ${await response.text()}`);
    }
    
    async function getOpenIssues() {
      return await fetchJson(`https://api.github.com/repos/${OWNER}/${REPO}/issues?state=open&labels=pending-manifestation`);
    }
    
    async function updateIssueLabel(issueNumber, labels) {
      await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/issues/${issueNumber}`, {
        method: 'PATCH',
        headers: { Authorization: `token ${GITHUB_TOKEN}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ labels })
      });
    }
    
    async function addCommentToIssue(issueNumber, comment) {
      await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/issues/${issueNumber}/comments`, {
        method: 'POST',
        headers: { Authorization: `token ${GITHUB_TOKEN}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ body: comment })
      });
    }
    
    async function updateReadme(content) {
      const res = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/README.md`, {
        headers: { Authorization: `token ${GITHUB_TOKEN}` }
      });
      const data = await res.json();
      const encoded = btoa(content);

      await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/README.md`, {
        method: 'PUT',
        headers: { Authorization: `token ${GITHUB_TOKEN}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: 'Atualiza√ß√£o autom√°tica do README ap√≥s nova manifesta√ß√£o',
          content: encoded,
          sha: data.sha
        })
      });
    }
    
    async function getAllUsersFromIssues() {
      const issues = await getOpenIssues();
      return issues.map(issue => {
        const corpo = issue.body;
        const nomeMatch = corpo.match(/Nome:\s*(.+)/);
        const emailMatch = corpo.match(/Email:\s*(.+)/);
        return {
          nome: nomeMatch ? nomeMatch[1].trim() : 'An√¥nimo',
          email: emailMatch ? emailMatch[1].trim() : null
        };
      });
    }
    
    // Fun√ß√µes de utilidade para rituais
    function calcularFaseLunar() {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const day = now.getDate();

      let r = year % 100;
      r %= 19;
      if (r > 9) r -= 19;
      r = ((r * 11) % 30) + month + day;
      if (month < 3) r += 2;
      let fase = (r + 8) % 30;
      fase = (fase / 30.0) * 360;
      if (fase < 0) fase += 360;

      return fase;
    }
    
    function gerarCodigoQuantico(intento, nome, data) {
      const seed = intento + nome + data + calcularFaseLunar();
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        const char = seed.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      hash = Math.abs(hash) % 1000000000000;
      const str = hash.toString().padStart(12, '0');
      return `${str.slice(0,4)}-${str.slice(4,8)}-${str.slice(8,12)}`;
    }
    
    function calcularNumeroDestinoAvancado(nome, data) {
      const nomeVal = [...nome.toLowerCase()].reduce((acc, c) => acc + (c >= 'a' && c <= 'z' ? c.charCodeAt(0) - 96 : 0), 0);
      let dia, mes, ano;
      try { [dia, mes, ano] = data.split('/').map(Number); } catch { [dia, mes, ano] = [0, 0, 0]; }
      const dataVal = dia + mes + ano;
      let total = (nomeVal * dataVal) % 108;
      while (total > 9) total = total.toString().split('').reduce((sum, d) => sum + parseInt(d), 0);
      return total || 9;
    }
    
    // Motor de Retrocausalidade Qu√¢ntica
    class QuantumRealityEngine {
      constructor() {
        this.entangledStates = new Map();
        this.retrocausalEvents = [];
        this.initializeQuantumField();
      }
      
      initializeQuantumField() {
        // Simula a cria√ß√£o de um campo qu√¢ntico toroidal
        this.quantumField = [];
        for (let i = 0; i < 64; i++) {
          this.quantumField.push(Array(64).fill(0).map(() => Math.random() * 2 - 1));
        }
      }
      
      entangleManifestation(manifestationId, intent, userData) {
        const entanglementCode = this.generateEntanglementCode(manifestationId, intent, userData);
        this.entangledStates.set(manifestationId, {
          code: entanglementCode,
          intent: intent,
          userData: userData,
          timestamp: Date.now(),
          probabilityWave: this.calculateProbabilityWave(intent)
        });
        
        return entanglementCode;
      }
      
      generateEntanglementCode(id, intent, userData) {
        const seed = `${id}-${intent}-${userData.nome}-${userData.dataNascimento}`;
        return CryptoJS.SHA256(seed).toString(CryptoJS.enc.Hex).substring(0, 24);
      }
      
      calculateProbabilityWave(intent) {
        // Simula uma fun√ß√£o de onda de probabilidade baseada na inten√ß√£o
        const complexity = intent.length % 7;
        const amplitude = 0.5 + (complexity * 0.1);
        const frequency = 0.3 + (complexity * 0.05);
        
        return {
          amplitude,
          frequency,
          collapseThreshold: 0.7 + (Math.random() * 0.2)
        };
      }
      
      simulateCollapse(manifestationId) {
        const state = this.entangledStates.get(manifestationId);
        if (!state) return false;
        
        // Simula o colapso da fun√ß√£o de onda
        const wave = state.probabilityWave;
        const collapseValue = Math.random();
        const success = collapseValue >= wave.collapseThreshold;
        
        if (success) {
          this.recordRetrocausalEvent(manifestationId, state);
        }
        
        return success;
      }
      
      recordRetrocausalEvent(manifestationId, state) {
        this.retrocausalEvents.push({
          id: manifestationId,
          timestamp: Date.now(),
          code: state.code,
          intent: state.intent,
          retrocausalAdjustment: this.calculateRetrocausalAdjustment()
        });
      }
      
      calculateRetrocausalAdjustment() {
        // Simula o ajuste retrocausal no continuum espa√ßo-temporal
        return {
          temporalDisplacement: Math.random() * 0.1 - 0.05,
          probabilityShift: 0.3 + (Math.random() * 0.4),
          resonanceFactor: 0.5 + (Math.random() * 0.5)
        };
      }
    }
    
    // Gerador de Artefatos Visuais
    class VisualArtifactGenerator {
      constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = 512;
        this.canvas.height = 512;
      }
      
      generateRadionicPattern(intent, code, userName) {
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Desenha padr√£o radi√¥nico baseado no c√≥digo qu√¢ntico
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const maxRadius = Math.min(centerX, centerY) - 20;
        
        // Converte o c√≥digo em valores num√©ricos para o padr√£o
        const values = code.split('').filter(c => c !== '-').map(c => parseInt(c, 16) || 0);
        
        // Desenha c√≠rculos conc√™ntricos
        this.ctx.strokeStyle = '#0ff';
        this.ctx.lineWidth = 2;
        
        for (let i = 0; i < values.length; i++) {
          const radius = (maxRadius * (i + 1)) / values.length;
          const value = values[i];
          
          this.ctx.beginPath();
          this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Desenha pontos/marcadores baseados no valor
          const points = value + 1;
          for (let j = 0; j < points; j++) {
            const angle = (j / points) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            this.ctx.fillStyle = '#f0f';
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
          }
        }
        
        // Adiciona texto com a inten√ß√£o e nome
        this.ctx.fillStyle = '#ff0';
        this.ctx.font = '16px DejaVu Sans';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(intent, centerX, 30);
        this.ctx.fillText(userName, centerX, this.canvas.height - 20);
        this.ctx.fillText(code, centerX, this.canvas.height - 40);
        
        return this.canvas.toDataURL('image/png');
      }
      
      generateQuantumSignature(code) {
        // Gera uma assinatura qu√¢ntica visual √∫nica baseada no c√≥digo
        const signatureCanvas = document.createElement('canvas');
        signatureCanvas.width = 256;
        signatureCanvas.height = 256;
        const sigCtx = signatureCanvas.getContext('2d');
        
        sigCtx.fillStyle = 'rgba(0, 0, 0, 0)';
        sigCtx.fillRect(0, 0, signatureCanvas.width, signatureCanvas.height);
        
        const hexValues = code.replace(/-/g, '').split('');
        const centerX = signatureCanvas.width / 2;
        const centerY = signatureCanvas.height / 2;
        
        sigCtx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
        sigCtx.lineWidth = 1;
        
        // Desenha padr√£o √∫nico baseado nos valores hexadecimais
        for (let i = 0; i < hexValues.length; i++) {
          const value = parseInt(hexValues[i], 16);
          const angle = (i / hexValues.length) * Math.PI * 2;
          const radius = (signatureCanvas.width / 2) * (value / 16);
          
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          if (i === 0) {
            sigCtx.beginPath();
            sigCtx.moveTo(x, y);
          } else {
            sigCtx.lineTo(x, y);
          }
        }
        
        sigCtx.closePath();
        sigCtx.stroke();
        
        return signatureCanvas.toDataURL('image/png');
      }
    }
    
    // Sistema de Energiza√ß√£o e Ativa√ß√£o
    class EnergizationSystem {
      constructor() {
        this.activationCycles = 0;
        this.currentEnergyLevel = 0;
        this.maxEnergyLevel = 100;
      }
      
      async energizeManifestation(manifestationData) {
        this.displayStatus(`Energizando manifesta√ß√£o: ${manifestationData.intent}`);
        
        // Simula processo de energiza√ß√£o em 3 fases
        await this.phase1Activation(manifestationData);
        await this.phase2Resonance(manifestationData);
        await this.phase3Anchoring(manifestationData);
        
        this.activationCycles++;
        return true;
      }
      
      async phase1Activation(manifestationData) {
        this.displayStatus("Fase 1: Ativa√ß√£o do Campo Qu√¢ntico");
        await this.delay(1000);
        this.animateQubits();
        
        // Simula ativa√ß√£o do campo qu√¢ntico
        for (let i = 0; i < 20; i++) {
          this.currentEnergyLevel = Math.min(this.maxEnergyLevel, this.currentEnergyLevel + 5);
          await this.delay(100);
        }
      }
      
      async phase2Resonance(manifestationData) {
        this.displayStatus("Fase 2: Sincroniza√ß√£o de Resson√¢ncia");
        await this.delay(1500);
        
        // Simula sincroniza√ß√£o de resson√¢ncia
        for (let i = 0; i < 10; i++) {
          this.pulseEnergyField();
          await this.delay(200);
        }
      }
      
      async phase3Anchoring(manifestationData) {
        this.displayStatus("Fase 3: Ancoragem na Realidade");
        await this.delay(1000);
        
        // Simula ancoragem na realidade
        for (let i = 0; i < 5; i++) {
          this.anchorReality();
          await this.delay(300);
        }
      }
      
      animateQubits() {
        const qubits = document.querySelectorAll('.qubit');
        qubits.forEach(qubit => {
          qubit.classList.toggle('active');
          setTimeout(() => qubit.classList.toggle('active'), 500);
        });
      }
      
      pulseEnergyField() {
        const panel = document.querySelector('.ritual-panel');
        panel.classList.add('pulse');
        setTimeout(() => panel.classList.remove('pulse'), 1000);
      }
      
      anchorReality() {
        // Efeito visual de ancoragem
        document.body.style.backgroundColor = '#001a33';
        setTimeout(() => {
          document.body.style.backgroundColor = '';
        }, 200);
      }
      
      displayStatus(message) {
        const statusEl = document.getElementById('status');
        statusEl.textContent = message;
        statusEl.className = 'status';
      }
      
      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
    }
    
    // Inicializa√ß√£o do sistema
    const quantumEngine = new QuantumRealityEngine();
    const artifactGenerator = new VisualArtifactGenerator();
    const energizationSystem = new EnergizationSystem();
    
    // Processamento do formul√°rio
    document.getElementById('manifestForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const intent = document.getElementById('intent').value;
      const name = document.getElementById('name').value;
      const birthDate = document.getElementById('birthDate').value;
      
      if (!intent || !name || !birthDate) {
        alert('Por favor, preencha todos os campos obrigat√≥rios.');
        return;
      }
      
      // Gera c√≥digo qu√¢ntico √∫nico
      const quantumCode = gerarCodigoQuantico(intent, name, birthDate);
      const numeroDestino = calcularNumeroDestinoAvancado(name, birthDate);
      
      // Prepara dados da manifesta√ß√£o
      const manifestationData = {
        intent,
        name,
        birthDate,
        quantumCode,
        numeroDestino,
        timestamp: new Date().toISOString(),
        phase: calcularFaseLunar()
      };
      
      // Exibe informa√ß√µes na interface
      document.getElementById('manifestation-display').innerHTML = `
        <div>
          <strong>Inten√ß√£o:</strong> ${intent}<br>
          <strong>C√≥digo Qu√¢ntico:</strong> ${quantumCode}<br>
          <strong>N√∫mero de Destino:</strong> ${numeroDestino}<br>
          <strong>Fase Lunar:</strong> ${manifestationData.phase.toFixed(1)}¬∞
        </div>
      `;
      
      try {
        // Processa a manifesta√ß√£o
        await processManifestation(manifestationData);
      } catch (error) {
        console.error('Erro no processo de manifesta√ß√£o:', error);
        document.getElementById('status').textContent = `Erro: ${error.message}`;
      }
    });
    
    // Processamento principal da manifesta√ß√£o
    async function processManifestation(manifestationData) {
      // 1. Cria issue no GitHub
      const issueNumber = await createManifestationIssue(manifestationData);
      
      // 2. Entrela√ßa a manifesta√ß√£o no campo qu√¢ntico
      const entanglementCode = quantumEngine.entangleManifestation(
        issueNumber, 
        manifestationData.intent, 
        { nome: manifestationData.name, dataNascimento: manifestationData.birthDate }
      );
      
      // 3. Gera artefatos visuais
      const radionicPattern = await generateRadionicPattern(manifestationData);
      const quantumSignature = await generateQuantumSignature(manifestationData.quantumCode);
      
      // 4. Energiza a manifesta√ß√£o
      await energizationSystem.energizeManifestation(manifestationData);
      
      // 5. Simula colapso qu√¢ntico
      const success = quantumEngine.simulateCollapse(issueNumber);
      
      if (success) {
        // 6. Atualiza issue com resultado
        await updateIssueWithResult(issueNumber, manifestationData, radionicPattern, quantumSignature);
        
        // 7. Atualiza p√°gina de realiza√ß√µes
        await updateRealizationsPage(manifestationData);
        
        document.getElementById('status').textContent = 
          `‚úÖ Manifesta√ß√£o conclu√≠da com sucesso! C√≥digo: ${manifestationData.quantumCode}`;
      } else {
        document.getElementById('status').textContent = 
          `‚è≥ Manifesta√ß√£o em processamento. Continue energizando sua inten√ß√£o.`;
      }
    }
    
    async function createManifestationIssue(manifestationData) {
      if (!GITHUB_TOKEN) {
        throw new Error('Token GitHub n√£o configurado. Use o painel de configura√ß√µes.');
      }
      
      const issueBody = `
**Inten√ß√£o:** ${manifestationData.intent}
**Nome:** ${manifestationData.name}
**Data de Nascimento:** ${manifestationData.birthDate}
**C√≥digo Qu√¢ntico:** ${manifestationData.quantumCode}
**N√∫mero de Destino:** ${manifestationData.numeroDestino}
**Timestamp:** ${manifestationData.timestamp}
**Fase Lunar:** ${manifestationData.phase}¬∞

---

*Esta issue foi criada automaticamente pelo Servidor do Caos como parte de um ritual de tecnomagia qu√¢ntica.*
      `;
      
      const response = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/issues`, {
        method: 'POST',
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
          'Content-Type': 'application/json',
          Accept: 'application/vnd.github.v3+json'
        },
        body: JSON.stringify({
          title: `Manifesta√ß√£o: ${manifestationData.intent.substring(0, 60)}...`,
          body: issueBody,
          labels: ['pending-manifestation', 'quantum-entangled']
        })
      });
      
      if (!response.ok) {
        throw new Error(`Falha ao criar issue: ${response.status} ${await response.text()}`);
      }
      
      const issueData = await response.json();
      return issueData.number;
    }
    
    async function generateRadionicPattern(manifestationData) {
      const dataUrl = artifactGenerator.generateRadionicPattern(
        manifestationData.intent,
        manifestationData.quantumCode,
        manifestationData.name
      );
      
      // Converte data URL para blob para upload
      const response = await fetch(dataUrl);
      const blob = await response.blob();
      
      const filename = `radionic_${manifestationData.quantumCode.replace(/-/g, '_')}.png`;
      await uploadFileToRepo(filename, blob);
      
      return filename;
    }
    
    async function generateQuantumSignature(code) {
      const dataUrl = artifactGenerator.generateQuantumSignature(code);
      
      const response = await fetch(dataUrl);
      const blob = await response.blob();
      
      const filename = `signature_${code.replace(/-/g, '_')}.png`;
      await uploadFileToRepo(filename, blob);
      
      return filename;
    }
    
    async function updateIssueWithResult(issueNumber, manifestationData, radionicPattern, quantumSignature) {
      const resultBody = `
## üåü MANIFESTA√á√ÉO CONCLU√çDA üåü

**Inten√ß√£o realizadora:** ${manifestationData.intent}
**C√≥digo Qu√¢ntico:** ${manifestationData.quantumCode}
**Timestamp da realiza√ß√£o:** ${new Date().toISOString()}
**Artefatos gerados:** 
- [Padr√£o Radi√¥nico](${radionicPattern})
- [Assinatura Qu√¢ntica](${quantumSignature})

### Processo de Realiza√ß√£o:
1. ‚úÖ Entrela√ßamento qu√¢ntico estabelecido
2. ‚úÖ Padr√£o radi√¥nico gerado e calibrado
3. ‚úÖ Energiza√ß√£o em 3 fases conclu√≠da
4. ‚úÖ Colapso da fun√ß√£o de onda realizado
5. ‚úÖ Ancoragem retrocausal efetivada

*A realidade agora se reorganiza para refletir esta nova probabilidade.*
      `;
      
      // Adiciona coment√°rio com o resultado
      await addCommentToIssue(issueNumber, resultBody);
      
      // Atualiza labels da issue
      await updateIssueLabel(issueNumber, ['manifested', 'quantum-collapsed', 'reality-anchored']);
    }
    
    async function updateRealizationsPage(manifestationData) {
      // Esta fun√ß√£o seria implementada para atualizar a p√°gina de realiza√ß√µes
      // Como estamos no GitHub Pages, isso pode ser feito atualizando um arquivo JSON
      // ou a pr√≥pria p√°gina HTML via GitHub API
      console.log('Atualizando p√°gina de realiza√ß√µes com:', manifestationData);
    }
    
    // Controle dos ciclos astrol√≥gicos
    function calculateNextAstrologicalWindow() {
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      
      // Encontra o pr√≥ximo hor√°rio astrol√≥gico
      for (const window of HORARIOS_ASTROLOGICOS) {
        if (window.h > currentHour || (window.h === currentHour && window.m > currentMinute)) {
          const nextDate = new Date(now);
          nextDate.setHours(window.h, window.m, 0, 0);
          return nextDate;
        }
      }
      
      // Se n√£o encontrou, √© o primeiro do pr√≥ximo dia
      const nextDate = new Date(now);
      nextDate.setDate(nextDate.getDate() + 1);
      nextDate.setHours(HORARIOS_ASTROLOGICOS[0].h, HORARIOS_ASTROLOGICOS[0].m, 0, 0);
      return nextDate;
    }
    
    function updateNextCycleDisplay() {
      const nextCycle = calculateNextAstrologicalWindow();
      const options = { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      };
      
      document.getElementById('next-cycle').textContent = 
        `Pr√≥ximo ciclo astrol√≥gico: ${nextCycle.toLocaleDateString('pt-BR', options)}`;
    }
    
    // Inicializa√ß√£o da interface
    function initializeInterface() {
      updateNextCycleDisplay();
      setInterval(updateNextCycleDisplay, 60000); // Atualiza a cada minuto
      
      // Verifica se temos token configurado
      if (!GITHUB_TOKEN) {
        document.getElementById('status').textContent = 
          '‚ö†Ô∏è Configure seu token GitHub nas configura√ß√µes para ativar o sistema.';
      } else {
        document.getElementById('status').textContent = 
          'Sistema pronto para manifesta√ß√µes qu√¢nticas.';
      }
    }
    
    // Inicia o sistema quando a p√°gina carrega
    window.addEventListener('load', initializeInterface);
  </script>
</body>

</html>
